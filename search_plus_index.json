{"./":{"url":"./","title":"首页","keywords":"","body":"首页 版本控制系统 版本控制，也称为源代码控制，是一种跟踪和管理软件代码变更的实践。版本控制系统是软件工具，可跟踪对代码的每一次修改。如果犯了错误，开发人员可以回退并比较代码的早期版本，以帮助修复错误，同时最大限度地减少对所有团队成员的干扰。 版本控制系统有以下三种分类 本地化版本控制系统 集中式版本控制系统 分布式版本控制系统 本地化版本控制系统：是最常见最简单的一种方法，但容错率高，在这种方法中，可能会忘记在哪个目录中，不小心写到了错误的文件或复制了你不想要的文件。 集中式版本控制系统 SVN 使用一个中央服务器来存储所有的数据库，这种方式需要开发人员需要与其他开发人员进行合作，系统中每个人都有对其他人文件的修改权力，但容易单点故障，也就是中央服务器的故障 分布式版本控制系统 Git 用户有一个版本库的本地副本。所以，客户不只是查看文件的最新快照，甚至他们可以完全镜像仓库。本地版本库包含主版本库中的所有文件和元数据 Git 与SVN 的区别 SVN是集中式版本控制系统，版本库是集中放在中央服务器的，必须联网才能推送到中央服务器上 Git 是分布式版本控制系统，每个人电脑是个完整的版本库，团队之间可以看见互相对方修改 Git 工作原理 Git 是一种分布式版本控制系统，它可以不受网络连接的限制，目前已经成为程序开发人员做项目版本管理时的首选，非开发人员也可以用 Git 来做自己的文档版本管理工具 使用 Git 托管工具创建“仓库”（项目） 将 Git 仓库复制（或克隆）到本地计算机 向本地仓库添加文件，然后“提交”（保存）更改 将变更“推送”到主分支 使用 Git 托管工具更改文件，并提交 将更改“拉取”到本地计算机 创建“分支”（版本），进行更改，提交更改 打开“拉取请求”（建议对主分支进行变更） 将您的分支“合并”到主分支 Git 安装与配置 Git目前有Linux/unix、Mac OS X和Windows三个版本 Git的Windows版本下载地址：https://git-scm.com/downloads // Redhat、Fedora、CentOS下的Git安装 yum install git; // Mac OS下的Git安装 brew install git; 安装成功后，在命令行下敲击下面的命令可以查看Git版本： # git --version Git配置 Git安装好后，需要填写一些个人的基本信息，例如提交人，邮件 git config --global user.email 1770285990@qq.com git config --global user.name “p5sf” 根据不同情况选择参数 —global：对当前用户下的所有仓库有效 —system：对当前系统下所有的用户有效 无参数：只对当前仓库有效 system：此后你在这个电脑上的所有提交都使用同一配置，哪怕你使用别的账号登录这台电脑。 global：这些配置只对你当前的用户有效，在Linux多用户系统下，建议使用这种配置，不会影响到其他用户的使用。 无参数配置：避免混淆公司项目和个人项目，因为每个仓库都有各自的name 和 Email "},"Git.html":{"url":"Git.html","title":"入门","keywords":"","body":"入门 git是一种源码管理系统（source code management）它对当前文件提供版本管理功能，核心思想是对当前文件建立一个对象数据库，将历史版本信息存放在这个数据库中 Git 安装 第一步：根据平台选择下载安装Git # 测试是否安装成功，显示版本号，则表示安装成功。 git --version 第二步：初始化Git配置 # 显示当前的Git配置 $ git config --list # 设置提交代码时的用户信息 $ git config --global user.name \"[name]\" $ git config --global user.email \"[email address]\" 第三步：上传公钥 # 生成私钥和公钥 ssh-keygen -t rsa -C \"your@email.com\" # 查看公钥 Linux： cat ~/.ssh/id_rsa.pub windows：C:\\Users\\用户\\.ssh 第四步：在Github上创建项目 第五步：初始化代码并上传 echo \"# a\" >> README.md git init ## 添加文件 git add README.md # 添加git提交信息 git commit -m \"first commit\" ## 项目关联远程仓库(ssh或者SSL)或者先clone代码 注意添加自己的Git地址 git remote add origin https://XXXX.git ## 项目推送到master分支 git push -u origin \"master\" "},"Git-command.html":{"url":"Git-command.html","title":"基本命令","keywords":"","body":"基本命令 教程：阮一峰Git教程 创建仓库 添加空白仓库 git init git init NewDir 将文件添加到存储库 git add 克隆仓库 git clone https://github.com/onmpw/marked.git 克隆分支 git clone -branch master https://github.com/onmpw/marked.git 克隆标签 git clone -b v1.0 https://github.com/onmpw/marked.git 查看远程仓库 git remote -v 添加远程仓库 git remote add origin https://gitee.com/lianbing/MapDemo.git 拉取仓库 git fetch 拉取并合并(pull=fetch+merge) git pull origin master 查看远程仓库 git remote show origin 删除远程仓库 git push origin --delete 修改远程仓库地址 git remote set-url origin https://gitee.com/jfdfsdd/MapDemo.git 分支合并 git branch命令可以列出本地的所有分支。 $ git branch 创建一个名为MyBranch的新分支，但是依然停留在当前分支。 $ git branch MyBranch 在远程主机origin上创建一个MyBranch的分支，并与本地的同名分支建立追踪关系。 $ git push -u origin MyBranch 将当前分支改名为MyBranch。 $ git branch -m MyBranch 删除MyBranch分支，前提是该分支没有未合并的变动。 $ git branch -d MyBranch 强制删除MyBranch分支，不管有没有未合并变化。 $ git branch -D MyBranch 切换到MyBranch分支，当前的工作区会变为MyBranch分支的内容。 $ git checkout MyBranch 基于MyBranch分支创建一个新的NewBranch分支，新的NewBranch分支将成为当前的工作区。 $ git checkout -b NewBranch MyBranch 标签命令 标签代表历史版本，当发布不同的版本就使用标签 创建标签 git tag v1.0 标签列表 git tag 查看标签的具体修改信息 git show v1.0 创建附注标签 git tag -a v1.4 -m \"my version 1.4\" 推送到远程 git push origin v1.5 删除本地标签 git tag -d v1.0 文件暂存 场景：暂时保存没有提交的工作，所有没有commit的代码，都会暂时从工作区移除，回到上次commit时的状态 基本命令 # 暂时保存没有提交的工作 $ git stash # 恢复最近一次stash的文件 $ git stash pop # 丢弃最近一次stash的文件 $ git stash drop # 删除所有的stash $ git stash clear 查看内部保存多次修改 $ git stash list stash@{0}: WIP on new-feature: 5cedccc Try something crazy stash@{1}: WIP on new-feature: 9f44b34 Take a different direction stash@{2}: WIP on new-feature: 5acd291 Begin new feature 上面命令假设曾经运行过git stash命令三次。 git stash pop命令总是取出最近一次的修改，但是可以用git stash apply指定取出某一次的修改。 $ git stash apply stash@{1} 上面命令不会自动删除取出的修改，需要手动删除。 $ git stash drop stash@{1} 提交历史 主要用于查看 Git 的提交历史 git log命令按照提交时间从最晚到最早的顺序，列出所有 commit。 # 列出当前分支的版本历史 $ git log # 查看所有分支的操作记录 $ git reflog # 列出某个文件的版本历史，包括文件改名 $ git log --follow [file] 查看最近分支信息 # 查看每行分支记录 $ git log --oneline # 查看最近(2次)提交信息 $ git log -2 # 显⽰2周前开始到现在的历史记录,(since 2周前到现在 before 显示截至到2周前) $ git log --since=\"2 weeks ago\" 查看远程分支的变动情况。 $ git log remote/branch 查找log，搜索commit信息，-i表示搜索时忽略大小写。 $ git log --author=Andy$ git log -i --grep=\"Something in the message\" 查看某个范围内的commit $ git log origin/master..new 美化输出 git log --graph --decorate --pretty=oneline --abbrev-commit "},"Git-revert.html":{"url":"Git-revert.html","title":"撤退命令","keywords":"","body":"Git 撤退操作 将某次修改撤销到上一个版本，或者想撤销某次多余提交 撤销操作分为以下三种情况 未 add 到暂存区 已 add 但还没从commit 已commit 但还没 push 到远程仓库 已 push 到远程仓库 未 add 到暂存区 git checkout . //放弃所有修改文件 git restore . //放弃修改所有文件 已 add 但未commit 在暂存区(已add操作)保留已修改文件，放弃修改执行工作区操作 git reset HEAD fileName //恢复某个文件到工作区 git reset HEAD . //恢复所有文件到工作区 git reset //恢复所有文件到工作区 已commit 但未 push 远程仓库 撤退有以下几种结果：主要由三个选项 结果一、不保存代码修改 git reset --hard HEAD^ //回退上一次commit状态 git reset --hard commit_id //回退到某个commit版本、 结果二、保存修改 git reset --mixed HEAD^ git reset HEAD^ 结果三、只撤销commit 但不撤销add 添加的文件（保存代码修改） git reset --soft HEAD^ 结果四、撤销修改并回到最新版本 git fetch --all git reset --hard origin/master 参数详情: reset：会将暂存区的内容和本地已提交的内容全部恢复到未暂存的状态,不影响原来本地文件(未提交的也不受影响) ,也就是恢复到add之前 soft：不清空暂存区,将已提交的内容恢复到暂存区,不影响原来本地的文件(未提交的也不受影响),也就是恢复到commit之前 hard：清空暂存区,将已提交的内容的版本恢复到本地,本地的文件也将被回退的版本替换，也就是恢复到没开发之前 已 push 到远程仓库 git reset --hard HEAD^ //回退上一版本 git reset --hard commit_id //回退id版本号位置 git push origin HEAD --force //强制推送到远程，可能会收到保护 reset 和 revert 的区别 git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容 场景：如果回退分支的代码以后还需要的情况则使用git revert， 如果分支是提错了没用的代码，则使用 git reset "},"Git-scene.html":{"url":"Git-scene.html","title":"常见场景","keywords":"","body":"常见场景 提交信息错误 如果你的提交信息(commit message)写错了且这次提交还没有推送，通过下面的命令修改提交信息 git commit --amend --only git commit --amend --only -m 'xxxxxxx' 切换分支的正确使用 当开发时，出现紧急Bug 需要修复，但此时功能才开发一半，又不想先 commit 提交，这时就需要代码暂存 第一步：先暂存代码git stash 第二步：修改完紧急分支，然后切换到工作分支 第三步：恢复代码 git stash apply 如何合并分支 使用merge合并，如果有冲突，则会产生分支，难以清理提交记录 chery-pick只需要将commit 合并到develop 分支上 ，且不会产生分支，git提交图谱永远保持一条直线，再有，模块分支开发完成后，需要将多个commit 和为一个commit，再合并到develop 分支，避免多个commit，这也是不使用merge的原因 如何合并staging\\release分支 rebase 译为变基，合并同样不会产生分叉。当 develop 更新了许多功能，要合并到 staging 测试，不可能用 cherry-pick 一个一个把 commit 合并过去。因此要通过 rebase 一次性合并过去，并且保证了 staging 与 develop 完全同步 查看冲突的来龙去脉 在解冲突或者想要知道一段代码的来龙去脉的时候，git blame就是一个很强大的工具 git blame git blame -L start,end 查看某个文件之前的修改 git log --pretty=oneline git show hash值 #查看修改部分 git show -3 #之前3次修改 git show hash值:/某个文件 #查看完整的文件 删除最后一次提交 # 这会不可逆的改变你的历史，搞乱拉取历史 $ git reset HEAD^ --hard $ git push -f [remote] [branch] 如果还没有推送到远程，把Git重置(reset)到你最后一次提交前的状态(同时保存暂存的变化): (my-branch*)$ git reset --soft HEAD@{1} ==注意==：如果已经推送，唯一安全做法那会创建一个新的提交(commit)用于撤消前一个提交的所有变化(changes)；或者, 如果你推的这个分支是rebase-safe的 (例如：其它开发者不会从这个分支拉), 只需要使用 git push -f。 重置后找回内容 如果你意外的做了 git reset --hard, 你通常能找回你的提交(commit), 因为Git对每件事都会有日志，且都会保存几天 $ git reflog $ git reset --hard SHA1234 暂存内容添加到上一次提交 $ git commit --amend https://www.eet-china.com/mp/a249971.html "},"Git-rule.html":{"url":"Git-rule.html","title":"提交规范","keywords":"","body":"提交规范 分支规范 为了保持提交的整洁，方便后续维护，需要规范分支名称 master 分支：主分支受保护，常常用来部署线上的代码，它一般由 develop 以及hotfix 分支合并，任何时间都不能直接修改代码 develop 分支：开发分支受保护，保持最新代码以及Bug 修改后的代码，合并feature 分支然后测试代码，如果通过测试则合并master 分支上 releaser 分支：预上线分支，发布测试阶段，如果已经通过测试，可以创建版本号，从 develop分支派生，必须合并 develop分支 和 master 分支 hotfix 分支：紧急Bug 分支，从master分支派生，必须合并回develop 分支和master分支 feature 分支：功能分支，开发新功能，一般基于 develop 分支下创建 commit 格式 : type: 本次 commit 的类型，诸如 bugfix docs style 等 scope: 本次 commit 波及的范围 subject: 简明扼要的阐述下本次 commit 的主旨，在原文中特意强调了几点 1. 使用祈使句，是不是很熟悉又陌生的一个词，来传送门在此 祈使句 2. 首字母不要大写 3. 结尾无需添加标点 body: 同样使用祈使句，在主体内容中我们需要把本次 commit 详细的描述一下，比如此次变更的动机，如需换行，则使用 | footer: 描述下与之关联的 issue 或 break change，详见案例 Type 类型 feat: 添加新特性 fix: 修复bug docs: 仅仅修改了文档 style: 仅仅修改了空格、格式缩进、都好等等，不改变代码逻辑 refactor: 代码重构，没有加新功能或者修复bug perf: 增加代码进行性能测试 test: 增加测试用例 chore: 改变构建流程、或者增加依赖库、工具等 案例如下 docs(guide/component):add missing : chore: fix eslint error chore(docs-app): enusre Toc links contain the path fix(grunt-utils): correctly detect java "},"GitFlow.html":{"url":"GitFlow.html","title":"Git 工作模式","keywords":"","body":"Git 工作模式 介绍以下常见的 Git 的工作流程，可以根据不同场景选择不同的工作模式，要求团队成员遵守的一种代码管理方案 集中式工作流 为了协作不同客户机之间的协同合作，Git 版本控制系统一般会设置一个中央版本服务器，集中式工作流像 SVN 一样，只有一个主分支，开发人员直接提交 master 分支并使用 使用场景：小型团队或 长时间使用SVN 的小团队 使用方式：组长创建远程仓库，创建 master分支，每个成员都可以在master分支上修改 分支工作流 在集中式工作流基础上，创建一个新分支，每有一个新功能就会创建一个新分支开发，即在 master 分支上创建一个新分支，功能完成后，再合并到主分支上 使用场景：小型团队，熟悉Git分支的团队 使用方式：组长创建 master分支，组员只读不写，基于 master 分支创建 feature 分支，在feature 分支上更新代码推送代码，然后 pull request 提醒组长，组长再把 feature 分支拉取进行审核，合并 master 分支，最后再删除 feature 分支 [!Tip] 组长或组员可以审核代码，并提出建议并讨论，但会增加组长的工作量，在主分支上直接测试 GitHub 工作流 [!note] 开发团队比较流行的工作流之一，是GitFlow的简化， develop 分支与 master 分支是并行存在的，一般在DEV分支上创建新的分支开发功能，完成再合并 develop 分支测试，通过后再合并到 master分支部署 使用场景：Github flow 的最大优点就是简单，合适\"持续发布\"的产品 使用流程： 第一步：根据需求，从master拉出新分支，不区分功能分支或补丁分支 第二步：新分支开发完成后，或者需要讨论的时候，就向master发起一个pull request（简称PR） 第三步：Pull Request既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码。对话过程中，你还可以不断提交代码 第四步：你的Pull Request被接受，合并进master，重新部署后，原来你拉出来的那个分支就被删除。（先部署再合并也可。） GitFlow工作流 [!Note] 是大型公司常见的工作流，每个分支都有不同的功能，功能完成后合并到 develop 分支，如果测试通过则发行版本 release 分支，再合并到 master分支上部署代码 最常见的工作模式，每个分支都有不同的功能，例如 DEV 开发分支，PRO生产分支，每次提交分支不与 master 分支直接交互，而是进入功能分支进行交互，master 分支部署生产环境、release 分支不包含新功能而是发布版本，一旦将此分支与 master 分支合并并部署到生产环境后，之后合并回到 develop 分支再创建新功能分支 使用场景：大型团队 使用方式：项目维护者创建 master 分支和DEV 分支，贡献者可读不可写。每次创建新功能创建 feature 分支，在feature 分支上进行开发，然后pull request 提醒项目维护者，然后在 DEV分支上测试并合并。如果测试通过会创建 release 发行分支，然后打上版本号 Forking 工作流 [!Note] 分叉工作流又叫分布式工作流，是GitFlow的衍生，常常用于公共开源项目。有两个服务器Git仓库，一个是私有个人仓库，一个公共仓库(项目维护者) 这种使每个程序员都有一个服务端，此仓库只有自己可以推送，其他人只能拉取，但不能推送到正式仓库，只有项目维护者才能推送到正式仓库，这样项目维护者可以接受所有开发者的提交 工作流程如下： 开发人员 fork 官方的服务端仓库，创建属于自己的私有服务端仓库 开发人员将代码 clone 到本地并开发并推送到自己的服务器终端仓库 开发人员指定仓库并和项目维护者创建 pull request 请求 项目维护者同意PR请求之后，该分支被合并到项目维护者的仓库 使用场景：开源社区的开源项目 使用方式：Fork 维护者的项目到自己的远程仓库，随意修改也不影响源仓库的代码，通过 pull request 推送到项目维护者的仓库 # 添加项目维护者仓库，更新项目 git remote add upstream https://the.official.repo.address "}}